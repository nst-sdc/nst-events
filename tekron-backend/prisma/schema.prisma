generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model Participant {
    id           String    @id @default(uuid())
    email        String    @unique
    name         String
    password     String
    approved     Boolean   @default(false)
    qrCode       String?
    approvedById String?
    approvedAt   DateTime?
    createdAt    DateTime  @default(now())

    assignedEventId String?
    event           Event?  @relation(fields: [assignedEventId], references: [id])

    approvedBy        Admin?             @relation("AdminApprovals", fields: [approvedById], references: [id])
    approvals         ApprovalLog[]
    eventParticipants EventParticipant[]

    // New fields
    pushToken String? // Expo push token for notifications
    xp        Int     @default(0)
    level     Int     @default(1)

    // Relations
    badges        ParticipantBadge[]
    feedback      Feedback[]
    photos        Photo[]
    reportedItems LostFoundItem[]    @relation("ReportedBy")
    claimedItems  LostFoundItem[]    @relation("ClaimedBy")
}

model Admin {
    id        String   @id @default(uuid())
    email     String   @unique
    name      String
    password  String
    createdAt DateTime @default(now())

    approvals     ApprovalLog[] @relation("AdminApprovalLogs")
    approvedUsers Participant[] @relation("AdminApprovals")

    // New field
    pushToken String?
}

model SuperAdmin {
    id        String   @id @default(uuid())
    email     String   @unique
    name      String
    password  String
    createdAt DateTime @default(now())
}

model ApprovalLog {
    id            String   @id @default(uuid())
    participantId String
    adminId       String
    approvedAt    DateTime @default(now())
    notes         String?

    participant Participant @relation(fields: [participantId], references: [id])
    admin       Admin       @relation("AdminApprovalLogs", fields: [adminId], references: [id])
}

enum EventStatus {
    UPCOMING
    LIVE
    PAUSED
    COMPLETED
    CANCELLED
}

model Event {
    id           String             @id @default(uuid())
    title        String
    description  String?
    location     String
    startTime    DateTime
    endTime      DateTime
    status       EventStatus        @default(UPCOMING)
    currentRound Int?
    createdAt    DateTime           @default(now())
    participants Participant[]
    leaderboard  EventParticipant[]

    venueId String?
    venue   Location? @relation(fields: [venueId], references: [id])

    feedback   Feedback[]
    volunteers Volunteer[]
}

model Location {
    id       String  @id @default(uuid())
    name     String
    building String
    floor    String
    mapCode  String? // e.g. code to map overlay or image URL
    isPublic Boolean @default(true)
    events   Event[]
}

model EventParticipant {
    id            String   @id @default(uuid())
    participantId String
    eventId       String
    score         Int      @default(0)
    rank          Int?
    updatedAt     DateTime @default(now())

    participant Participant @relation(fields: [participantId], references: [id])
    event       Event       @relation(fields: [eventId], references: [id])
}

model Alert {
    id          String   @id @default(uuid())
    title       String
    message     String
    createdAt   DateTime @default(now())
    senderRole  String // 'admin' or 'superadmin'
    isEmergency Boolean  @default(false)

    // New fields for targeting
    targetScope    String   @default("all") // 'all', 'event', 'participants'
    targetEventIds String[] // Array of event IDs if scope is 'event'
}

model Badge {
    id          String   @id @default(uuid())
    name        String
    description String?
    iconUrl     String?
    type        String // "participant", "winner", "volunteer", etc.
    createdAt   DateTime @default(now())

    awardedTo ParticipantBadge[]
}

model ParticipantBadge {
    id            String   @id @default(uuid())
    participantId String
    badgeId       String
    awardedAt     DateTime @default(now())

    participant Participant @relation(fields: [participantId], references: [id])
    badge       Badge       @relation(fields: [badgeId], references: [id])
}

// Future Features Models

model Volunteer {
    id        String   @id @default(uuid())
    email     String   @unique
    name      String
    password  String
    role      String   @default("volunteer")
    createdAt DateTime @default(now())

    // Volunteers can be assigned to specific events
    assignedEventId String?
    event           Event?  @relation(fields: [assignedEventId], references: [id])
}

model Feedback {
    id            String   @id @default(uuid())
    participantId String
    eventId       String
    rating        Int // 1-5
    comment       String?
    createdAt     DateTime @default(now())

    participant Participant @relation(fields: [participantId], references: [id])
    event       Event       @relation(fields: [eventId], references: [id])
}

model Photo {
    id         String   @id @default(uuid())
    uploaderId String
    url        String
    caption    String?
    status     String   @default("PENDING") // PENDING, APPROVED, REJECTED
    createdAt  DateTime @default(now())

    uploader Participant @relation(fields: [uploaderId], references: [id])
}

model LostFoundItem {
    id           String   @id @default(uuid())
    type         String // LOST | FOUND
    category     String   @default("OTHER") // ELECTRONICS | CLOTHING | ACCESSORIES | DOCUMENTS | OTHER
    title        String
    description  String?
    location     String?
    reportedById String
    claimedById  String?
    status       String   @default("OPEN") // OPEN | CLAIMED | CLOSED
    createdAt    DateTime @default(now())

    reportedBy Participant  @relation("ReportedBy", fields: [reportedById], references: [id])
    claimedBy  Participant? @relation("ClaimedBy", fields: [claimedById], references: [id])
}

model MagicLinkToken {
    id        String   @id @default(uuid())
    email     String
    token     String   @unique
    expiresAt DateTime
    createdAt DateTime @default(now())
}
